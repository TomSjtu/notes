# 原子操作

## 独占内存访问指令

ARMv8指令集提供了LDXR和STXR，用于实现对变量的原子操作。

LDXR是独占内存加载指令，它以独占的方式加载内存地址的值到通用寄存器。

STXR是独占内存存储指令，它以独占的方式将通用寄存器中的值存储到内存地址。执行的结果放在Ws寄存器中，如果该寄存器为0则执行成功

LDXP和STXP是多字节的独占内存访问指令。

## 独占监视器

独占内存访问指令LDXR和STXR通过独占监视器来监控对内存的访问。

独占监视器会把对应内存地址标记为独占访问模式，

!!! example "独占访问例子"

    ```
    1:
        ldxr x2, [x1]
        orr x2, x2, x0
        stxr w3, x2, [x1]
        cbnz w3, 1b
    ```

最后一行通过判断W3寄存器的值来判断是否执行成功，如果不为0则跳转到标签1处重新执行。

注意，LDXR和STXR指令必须配对使用，位于这两条指令之间的代码是原子的。

独占监视器一共有两种状态——{==开放访问状态==}和{==独占访问状态==}。

当CPU通过LDXR指令从内存加载数据时，CPU会把这个内存地址标记为独占访问，然后CPU内部的独占监视器的状态就变为独占访问状态。当执行到STXR指令时，需要根据独占监视器的状态来做决定：

- 如果是独占访问状态并且STXR指令要存储的地址正好是刚才标记过的地址，那么STXR指令执行成功，返回0,并且独占监视器的状态变为开放访问状态。
- 如果是开放访问状态，那么STXR指令执行失败，返回1,并且独占监视器的状态仍然保持开放访问状态。

ARMv8体系结构根据缓存一致性的层次关系分为了多个监视器：

- 本地独占监视器：监视本地CPU
- 内部缓存一致性全局独占监视器：监视内部缓存一致性
- 外部全局独占监视器：监视外部缓存一致性

## 原子内存访问指令

ARMv8体系结构中新增了原子内存访问指令，该指令需要AMBA 5总线中的CHI(Coherent Hub Interface)的支持。AMBA 5总线引入了{==原子事务==}(atomic transaction)的概念，允许将原子操作发送到数据，并且允许原子操作在靠近数据的地方执行，而不需要加载到高速缓存中处理。原子事务非常适合要操作的数据离处理器核心比较远的地方，比如数据在内存中。

原子内存访问指令与独占内存访问指令最大区别在于效率。设想一个SMP系统，假如共享资源存储在内存中，使用独占内存访问指令会导致所有CPU核心都将锁加载到L1高速缓存中，然后不停地尝试获取锁和检查独占监视器的状态，在锁竞争激烈的时候会造成{==高速缓存颠簸==}现象，并且整个过程还需要MESI(缓存一致性)协议来处理L1高速缓存一致性。这个场景在NUMA架构下更加明显，远端节点的CPU需要不断地跨节点访问数据。另外一个问题是不公平，当锁持有者释放锁时，所有的CPU都需要争抢这把锁，有可能最先申请锁的CPU反而没有抢到锁。

