# 页高速缓存与页回写

页高速缓存是一种把磁盘的数据缓存到物理内存中的机制，使得对磁盘的访问变为对物理内存的访问。高速缓存的重要性体现在：

1. 访问磁盘的速度远远低于访问内存的速度。

2. 数据一旦被访问，就很有可能在短期内再次被访问。这就是局部性原理。

当内核开始一个读操作，它首先会检查需要的数据是否在页高速缓存中。如果在，放弃访问磁盘，而直接从内存中读取。这个行为称为{==缓存命中==}（cache hit）。否则称为{==缓存未命中==}（cache miss），那么内核必须调度块I/O操作去磁盘中读取数据，然后将数据放入页缓存中。

内核采用{==预读机制==}：即当从磁盘中读取数据时，由于磁盘的读写单位为block（4KB），出于空间局部性原理，内核会将多个block的数据都加入到缓存中。

## 写缓存策略

在进程写磁盘时，缓存的使用一般有以下三种：

1. 不缓存：也就是说高速缓存不缓存任何写操作，而是直接写入磁盘。这种方式很少采用，因为性能非常差。

2. 写操作自动更新缓存，同时也更新磁盘文件：这种策略对缓存一致性非常有效，因为内存缓存始终和磁盘一致。

3. Linux采用的——回写：写操作写入缓存，但是磁盘并不立刻更新，而是将页高速缓存中被写入的页面标记为“{==脏==}”，然后加入到脏页列表中。由一个回写进程周期性的将脏页链表中的页回写至磁盘，最后清理脏页标识。

## 缓存回收策略

由于大量的页缓存在内存中，必然导致可用内存的下降。为了保证内存的正常使用，必须有一种机制可以回收缓存。Linux的缓存回收是通过选择干净页进行简单替换。如果缓存中没有足够的干净页，内核将强制性的进行回写操作，以腾出更多的干净页使用。

一种回收策略被称为最近最少使用算法，简称{==LRU==}（Least Recently Used）。LRU算法一般是用链表作为数据结构来实现的，链表头部的数据是最近使用的，而链表末尾的数据是最久没被使用的。当空间不够时，就淘汰最久没被使用的节点，也就是链表末尾的数据，从而腾出内存空间。传统的LRU算法对于那些只会被访问一次的文件效果尤其差。

Linux内核对LRU算法进行了改进，被称为{==双链策略==}——内核维护两个链表：活跃链表（active list）和不活跃链表（inactive list）。处于活跃链表上的页被认为是"热"的且不会换出，处于不活跃链表上的页被认为是"冷"的可以被换出。页面从尾部加入，从头部移除，就像队列一样。有了这两个LRU链表后，预读页就只需要加入到不活跃链表的头部，当页被真正访问的时候，才将页插入到活跃链表的头部。如果预读的页一直没有被访问，就会从不活跃链表中移除，这样就不会影响活跃链表中的热数据。

## Swap机制

在Linux操作系统中，当内存充足的时候，内核会尽量使用内存作为文件缓存，从而提高系统的性能，这样就可以避免耗时的I/O操作。

当内存资源紧张时，内核就会对一些内存进行回收。但并不是所有的内存都可以回收，比如进程的代码段、数据段，如果回收了进程就没法运行了。还有一些是进程申请锁定的页，也不允许回收。内核回收的页，主要分为以下两类：

- 文件页：也就是文件在内存中的缓存，大部分可以直接回收，如果是脏页就先写入磁盘
- 匿名页：进程申请的内存，通过swap机制，写入磁盘后释放

```C title="mmzone.h"
enum lru_list {
	LRU_INACTIVE_ANON = LRU_BASE,
	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
	LRU_UNEVICTABLE,
	NR_LRU_LISTS
};
```

根据这个enum我们也可以看到，内存回收主要针对匿名页以及文件页的active和inactive共计四种链表。

当有新的大块内存分配请求而剩余内存不足时，内核就会回收一部分内存，尽可能地满足新内存请求，这个过程被称为{==直接内存回收==}。

除了直接内存回收，还有一个专门的内核线程`kswapd`用来定期回收内存。为了衡量内存的使用情况，内核定义了三个内存阈值，分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high），剩余内存，则用pages_free表示。

![内存情况](../../images/kernel/pages_free.webp)

一旦剩余内存小于页低阈值，就会触发内存的回收。

在NUMA架构下，每个处理器都会被划分到不同的Node下，而每个Node都有自己的本地内存空间。因此，内核需要根据当前Node的内存使用情况来决定回收的目标。当某个Node内存不足时，内核可以从其他Node寻找空闲内存，也可以从本地回收内存，具体回收模式在/proc/sys/vm/zone_reclaim_mode文件中进行配置。

/proc/sys/vm/swappiness选项用来调整使用Swap的积极程度，范围是从0~100。数值越大越积极使用swap，也就是更倾向于回收匿名页；数值越小越消极使用swap，也就是更倾向于回收文件页。

如果以上这两种方式仍然不满足内存分配的要求，内核就会祭出终极大杀器——{==OOM killer==}，它会遍历内核中的所有进程，然后对其打分，最后kill掉得分最高的进程。