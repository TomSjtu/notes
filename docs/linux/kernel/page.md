# 页高速缓存与页回写

页高速缓存是一种把磁盘的数据缓存到物理内存中的机制，使得对磁盘的访问变为对物理内存的访问。高速缓存的重要性体现在：

1. 访问磁盘的速度远远低于访问内存的速度。

2. 数据一旦被访问，就很有可能在短期内再次被访问。这就是局部性原理。

当内核开始一个读操作，它首先会检查需要的数据是否在页高速缓存中。如果在，放弃访问磁盘，而直接从内存中读取。这个行为称为{==缓存命中==}（cache hit）。否则称为{==缓存未命中==}（cache miss），那么内核必须调度块I/O操作去磁盘中读取数据，然后将数据放入页缓存中。

内核采用{==预读机制==}：即当从磁盘中读取数据时，由于磁盘的读写单位为block（4KB），出于空间局部性原理，内核会将多个block的数据都加入到缓存中。

## 写缓存策略

在进程写磁盘时，缓存的使用一般有以下三种：

1. 不缓存：也就是说高速缓存不缓存任何写操作，而是直接写入磁盘。这种方式很少采用，因为性能非常差。

2. 写操作自动更新缓存，同时也更新磁盘文件：这种策略对缓存一致性非常有效，因为内存缓存始终和磁盘一致。

3. Linux采用的——回写：写操作写入缓存，但是磁盘并不立刻更新，而是将页高速缓存中被写入的页面标记为“{==脏==}”，然后加入到脏页列表中。由一个回写进程周期性的将脏页链表中的页回写至磁盘，最后清理脏页标识。

## 缓存回收策略

由于大量的页缓存在内存中，必然导致可用内存的下降。为了保证内存的正常使用，必须有一种机制可以回收缓存。Linux的缓存回收是通过选择干净页进行简单替换。如果缓存中没有足够的干净页，内核将强制性的进行回写操作，以腾出更多的干净页使用。

一种回收策略被称为最近最少使用算法，简称{==LRU==}（Least Recently Used）。LRU算法一般是用链表作为数据结构来实现的，链表头部的数据是最近使用的，而链表末尾的数据是最久没被使用的。当空间不够时，就淘汰最久没被使用的节点，也就是链表末尾的数据，从而腾出内存空间。传统的LRU算法对于那些只会被访问一次的文件效果尤其差。

Linux内核对LRU算法进行了改进，被称为{==双链策略==}——维护两个链表：活跃链表（active list）和不活跃链表（inactive list）。处于活跃链表上的页被认为是“热”的且不会换出，处于不活跃链表上的页被认为是“冷”的可以被换出。页面从尾部加入，从头部移除，就像队列一样。有了这两个LRU链表后，预读页就只需要加入到不活跃链表的头部，当页被真正访问的时候，才将页插入到活跃链表的头部。如果预读的页一直没有被访问，就会从不活跃链表中移除，这样就不会影响活跃链表中的热数据。