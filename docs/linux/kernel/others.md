# 其他

> 这里主要放一些零碎的内容。

## 系统调用

当你的程序调用open, read, write, close等函数时，就会触发系统调用（syscall）。系统调用本质是用户态进程与硬件设备交互的接口，内核负责检查系统调用的正确性，然后发出指令给硬件。作为应用程序开发者，不用关心底层硬件的实现细节，而只需要调用普通函数就可以使用系统调用了。glibc库进一步封装了细节，因此我们只需要使用glibc库暴露的API即可。

x86体系进入和退出系统调用有两种方式：

- int $0x80 和 iret
- sysenter 和 sysexit

第二种被称为快速系统调用。

无论哪种方式，最终结果都是跳转到系统调用处理函数（system call handler）。由于内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（system call number）的参数来识别所需的系统调用，这个参数存放在eax寄存器中。执行完系统调用后的返回值也放在eax寄存器中，其中正数或0表示系统调用成功，负数表示出错，存放于`errno`全局变量中。

系统调用处理流程是：

- 将系统调用的参数写入CPU寄存器
- 检查所有的系统调用参数
- 将CPU中的参数拷贝至内核态堆栈
- 调用名为系统调用服务例程（system call service routine）的C函数来处理系统调用
- 退出系统调用处理程序，将内核栈中的值加载至寄存器，并从内核态切换回用户态

为了将系统调用号与对应的服务例程联系起来，内核定义了一个系统调用分派表（system call dispatch table），这个表存放在`sys_call_table`数组中。内核拿到系统调用号之后，就去`sys_call_table`中找到对应的系统调用实现函数去执行。执行完毕后，使用返回指令从内核态返回至用户态。

内核在执行系统调用的时候处于进程上下文。`current`指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠并且可以被抢占。因此必须保证系统调用时可重入的，因为新的进程可能会使用相同的系统调用。

## 内核源码

要获取内核源码，请使用`git`。

```
git clone git://git.ernel.org/pub/scm/linux/kernel/git/torvalds/[linux版本号].git
```

内核源码树由许多目录组成，一些比较重要的目录的描述如下：

| 目录名 | 描述 |
| --- | --- |
| arch | 体系结构相关的代码 |
| block | 块设备I/O层 |
| drivers | 设备驱动程序 |
| fs | 文件系统 |
| include | 内核头文件 |
| init | 初始化代码 |
| ipc | 进程间通信代码 |
| kernel | 内核核心代码 |
| lib | 内核库函数 |
| mm | 内存管理 |
| net | 网络系统 |


要编译内核，请使用make menuconfig。内核的各种配置，以CONFIG_FEATURE的形式写入.config文件。配置选项有三种：yes、no或module。分别对应编译、不编译、以模块形式编译。

内核开发的特点如下：

- 不能使用标准C库头文件，只能使用内核提供的头文件。与体系结构无关的头文件位于内核源码根目录下的include目录。与体系结构相关的头文件位于<arch/architecture/include/asm\>目录，内核代码以asm前缀的形式包含这些头文件。

- 必须使用GNU C。gcc编译器支持以asm()指令开头嵌入汇编代码。

- 没有内存保护机制。如果是内核访问了非法内存，后果不堪设想。

- 无法执行浮点运算。内核对于浮点运算的支持度不够。

- 必须考虑同步与并发。Linux内核是抢占式多任务处理系统，当前任务随时有可能被另一个任务抢占。

- 必须考虑可移植性。比如保持字节序、64 位对齐、不假定字长和页面长度等一系列准则。