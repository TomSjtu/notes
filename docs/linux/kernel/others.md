# 其他

> 这里主要放一些零碎的内容。

## 系统调用

当你的程序调用open, read, write, close等函数时，就会触发系统调用（syscall）。系统调用本质是用户态进程与硬件设备交互的接口，内核负责检查系统调用的正确性，然后发出指令给硬件。作为应用程序开发者，不用关心底层硬件的实现细节，而只需要调用普通函数就可以使用系统调用了。glibc库进一步封装了细节，因此我们只需要使用glibc库暴露的API即可。

x86体系进入和退出系统调用有两种方式：

- int $0x80 和 iret
- sysenter 和 sysexit

第二种被称为快速系统调用。

无论哪种方式，最终结果都是跳转到系统调用处理函数（system call handler）。由于内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（system call number）的参数来识别所需的系统调用，这个参数存放在eax寄存器中。执行完系统调用后的返回值也放在eax寄存器中，其中正数或0表示系统调用成功，负数表示出错，存放于`errno`全局变量中。

系统调用处理流程是：

- 将系统调用的参数写入CPU寄存器
- 检查所有的系统调用参数
- 将CPU中的参数拷贝至内核态堆栈
- 调用名为系统调用服务例程（system call service routine）的C函数来处理系统调用
- 退出系统调用处理程序，将内核栈中的值加载至寄存器，并从内核态切换回用户态

为了将系统调用号与对应的服务例程联系起来，内核定义了一个系统调用分派表（system call dispatch table），这个表存放在`sys_call_table`数组中。内核拿到系统调用号之后，就去`sys_call_table`中找到对应的系统调用实现函数去执行。执行完毕后，使用返回指令从内核态返回至用户态。

内核在执行系统调用的时候处于进程上下文。`current`指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠并且可以被抢占。因此必须保证系统调用时可重入的，因为新的进程可能会使用相同的系统调用。

## 信号

在Linux系统中，为了响应各种事件定义了非常多的信号。比如当我们发送`kill -9 ${pid}`时，其实就是发送SIGKILL信号给指定进程，将它杀死。我们可以通过`kill -l`命令查看所有的信号。每个信号都有一个唯一的ID和对应的默认操作。

进程对信号的处理方式有三种：

1. 执行默认操作。
2. 自定义信号处理函数。
3. 忽略信号。注意，SIGKILL和SIGSTOP无法忽略。

Linux推荐使用`sigaction()`函数来自定义信号处理函数。它的定义如下：

```C
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

而sigaction结构体的定义如下：

```C
struct sigaction {
  __sighandler_t sa_handler;
  unsigned long sa_flags;
  __sigrestore_t sa_restorer;
  sigset_t sa_mask;   
};
```

其中`sa_handler`就是你要定义的信号处理函数。

发送信号由两种方式，一种是发送给整个线程组的，还有一种是发送给某个单独线程的。信号分为不可靠信号和可靠信号。在`task_struct`中有一个结构体`sigpending`，它的定义如下：

```C
struct sigpending{
    struct list_head list;
    sigset_t signal;
};
```

对于不可靠信号，也就是编号小于32的信号，会放在`sigset_t`集合中，不论发送多少次，在被处理前都只会保留一份。对于可靠信号，则会挂在`struct sigpending`的链表中挨个处理。

## 定时器

内核中有大量的函数是基于时间驱动的。有些函数需要周期性执行，有些函数需要等待一个相对时间后才运行。周期性的事件由系统定时器驱动。系统定时器能以固定的频率产生中断，这种中断被称为定时器中断，它所对应的中断处理程序负责更新系统时间和执行周期性任务。

系统定时器的频率被称为节拍率（tick rate），产生的两次时钟中断的间隔就被称为节拍（tick），它等于节拍率分之一秒。内核通过时钟中断间隔来计算系统运行时间。时钟中断需要执行的操作有：

- 更新系统运行时间
- 更新实际时间
- 在SMP系统上，均衡调度程序中各处理器上的运行队列
- 检查当前进程是否用尽了自己的时间片
- 运行超时的动态定时器
- 更新资源消耗和处理器时间的统计值

### 节拍率和jiffies变量

系统定时器频率是通过静态预处理定义的，在系统启动时按照HZ的值对硬件进行设置，该值与体系结构相关。内核在<asm/param.h\>文件中定义。在x86体系结构中，系统定时器频率默认为1000。也就是说x86的时钟中断频率为1000HZ，即每秒中断1000次（每1ms产生一次）。

时钟中断频率应设置为一个理想的值，高HZ可以提高系统的性能，使得由时间驱动的事件更为精确。但同时也带来了额外的系统负担，因为处理器会被更频繁地打断去执行时钟中断处理程序。

全局变量`jiffies`用来记录系统启动以来产生的节拍总数。内核在启动时将该变量初始化为0，此后每产生一次时钟中断该值就+1。因为一秒内时钟中断的次数等于HZ，所以`jiffies`一秒内增加的值也就为HZ。系统运行时间以秒为计，其值等于jiffies/HZ。

`jiffies`变量被定义为unsigned long类型。在32位体系结构上是32位。如果时钟频率为100HZ，那么497天后会溢出。如果是64位体系结构，任何人都别指望会看到它溢出。

当`jiffies`变量的值超过它的最大存放范围后就会发生溢出，此时再继续增加的话，它会回绕至0。为了解决`jiffies`变量的溢出问题，内核引入了`jiffies_64`变量，这是一个64位的无符号整数。但是用户空间访问的依然还是`jiffies`变量。

### 动态定时器

定时器的使用很简单。你只需要执行一些初始化工作，设置一个超时时间，指定超时发生后需要执行的函数，然后激活定时器就可以了。内核提供了一组与定时器相关的接口用来简化定时器的操作。

创建定时器：

```C
struct timer_list my_timer;
```

初始化定时器：

```C
init_timer(&my_timer);
```

填充定时器结构中的值：

```C
my_timer.expires = jiffies + delay;    //定时器超时节拍数
my_timer.data = 0;                     //定时器处理函数传入的值
my_timer.function = my_function;       //定时器超时回调函数
```

如果当前`jiffies`计数大于或等于my_timer.expires的值，那么my_timer.function指向的处理函数就会被执行。处理函数必须符合以下类型：

```C
void my_function(unsigned long data);
```

如果需要通过data参数传递多个数据项，可以将这些数据项捆绑成一个结构体，然后将结构体的指针强制转换成unsigned long传入。

最后，你必须手动激活定时器：

```C
add_timer(&my_timer);
```

一般来说，定时器都会在超时后马上执行，但也有可能会推迟到下一个时钟节拍时才运行，所以不能用定时器来实现任何硬实时的任务。如果需要修改定时器超时时间，可以通过`mod_timer()`函数来实现：

```C
mod_timer(&my_timer, jiffies + new_delay);
```

如果在定时器超时前停止定时器，可以使用`del_timer()`函数：

```C
del_timer(&my_timer);
```

需要注意的是，在SMP系统中，删除定时器时可能需要等待在其他处理器上运行的定时器处理程序都退出，这时需要用到`del_timer_syn()`函数来执行删除工作。在大多数情况下，都应该调用这个函数而不是`del_timer()`。在拥有锁的时候，需要做一些额外的检查，以防止死锁。

### 延迟执行

内核代码往往需要推迟某些任务的执行，这种推迟通常发生在等待硬件完成某些工作，而且等待时间往往非常短。内核提供了多种延迟方法来处理延迟请求。

最简单的延迟方法就是忙等待。该方法仅仅在想要延迟的时间是节拍的整数倍，或者精确率要求不高的情况下才可以使用。忙等待的实现非常简单——在一个循环中不断等待直到希望的时钟节拍数耗尽，比如：

```C
unsigned long timeout = jiffies + 10;    //等待10个节拍
while(time_before(jiffies, timeout))
{}
```

该循环将不断执行，直到`jiffies`大于delay为止。这是一种低效的办法， 因为处理器除了等待不会做任何事情，更好的方案是在等待时，允许内核重新调度执行其他任务。

基于`jiffies`的延迟方法受限于时钟节拍，无法提供更短、更精确的延迟要求。为此，内核提供了三个可以处理us、us和ms级别的短延迟函数：

```C
void ndelay(unsigned long nsecs)
void udelay(unsigned long usecs)
void mdelay(unsigned long msecs)
```

这些函数的实际实现在<asm/delay.h\>中，很明显，这些是与体系架构相关的函数。这三个函数都是忙等待函数，在延迟过程中无法运行其他任务。不涉及忙等待的函数有以下两个，它们会将当前进程置入休眠状态：

```C
void msleep(unsigned int millisecs);
void ssleep(unsigned int seconds);
```

更理想的延迟执行方法是使用`schedule_timeout()`函数，该方法让需要延迟执行的任务睡眠到指定延迟时间耗尽后再重新运行。其用法如下：

```C
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout(s * HZ);
```

上述代码将当前任务推入可中断睡眠队列，睡眠s秒后唤醒。注意，由于`schedule_timeout()`函数需要调用调度程序，所以调用它的代码必须保证能够睡眠。也就是调用函数必须位于进程上下文中，且不能持有锁。

当任务被重新调度时，将返回代码进入睡眠前的位置继续执行。如果任务提前被唤醒，那么定时器被撤销。

## 页高速缓存与页回写

页高速缓存是一种把磁盘的数据缓存到物理内存中的机制，使得对磁盘的访问变为对物理内存的访问。高速缓存的重要性体现在：

1. 访问磁盘的速度远远低于访问内存的速度。

2. 数据一旦被访问，就很有可能在短期内再次被访问。这就是局部性原理。

当内核开始一个读操作，它首先会检查需要的数据是否在页高速缓存中。如果在，放弃访问磁盘，而直接从内存中读取。这个行为称为**缓存命中**（cache hit）。否则称为**缓存未命中**（cache miss），那么内核必须调度块I/O操作去磁盘中读取数据，然后将数据放入页缓存中。内核采用**预读机制**：即当从磁盘中读取数据时，由于磁盘的读写单位为block（4KB），出于空间局部性原理，内核会将多个block的数据都加入到缓存中。

### 写缓存策略

在进程写磁盘时，缓存的使用一般有以下三种：

1. 不缓存：也就是说高速缓存不缓存任何写操作，而是直接写入磁盘。这种方式很少采用，因为性能非常差。

2. 写操作自动更新缓存，同时也更新磁盘文件：这种策略对缓存一致性非常有效，因为内存缓存始终和磁盘一致。

3. Linux采用的——回写：写操作写入缓存，但是磁盘并不立刻更新，而是将页高速缓存中被写入的页面标记为“脏”，然后加入到脏页列表中。由一个回写进程周期性的将脏页链表中的页回写至磁盘，最后清理脏页标识。

### 缓存回收策略

由于大量的页缓存在内存中，必然导致可用内存的下降。为了保证内存的正常使用，必须有一种机制可以回收缓存。Linux的缓存回收是她通过选择干净页进行简单替换。如果缓存中没有足够的干净页，内核将强制性的进行回写操作，以腾出更多的干净页使用。

一种回收策略被称为最近最少使用算法，简称LRU（Least Recently Used）。LRU算法一般是用链表作为数据结构来实现的，链表头部的数据是最近使用的，而链表末尾的数据是最久没被使用的。当空间不够时，就淘汰最久没被使用的节点，也就是链表末尾的数据，从而腾出内存空间。传统的LRU算法对于那些只会被访问一次的文件效果尤其差。

Linux内核对LRU算法进行了改进，被称为双链策略——维护两个链表：活跃链表（active list）和不活跃链表（inactive list）。处于活跃链表上的页被认为是“热”的且不会换出，处于不活跃链表上的页被认为是“冷”的可以被换出。页面从尾部加入，从头部移除，就像队列一样。有了这两个LRU链表后，预读页就只需要加入到不活跃链表的头部，当页被真正访问的时候，才将页插入到活跃链表的头部。如果预读的页一直没有被访问，就会从不活跃链表中移除，这样就不会影响活跃链表中的热数据。


## 可移植性




