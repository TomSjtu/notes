# 其他

> 这里主要放一些零碎的内容。

## 系统调用

当你的程序调用open, read, write, close等函数时，就会触发系统调用（syscall）。系统调用本质是用户态进程与硬件设备交互的接口，内核负责检查系统调用的正确性，然后发出指令给硬件。作为应用程序开发者，不用关心底层硬件的实现细节，而只需要调用普通函数就可以使用系统调用了。glibc库进一步封装了细节，因此我们只需要使用glibc库暴露的API即可。

x86体系进入和退出系统调用有两种方式：

- int $0x80 和 iret
- sysenter 和 sysexit

第二种被称为快速系统调用。

无论哪种方式，最终结果都是跳转到系统调用处理函数（system call handler）。由于内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（system call number）的参数来识别所需的系统调用，这个参数存放在eax寄存器中。执行完系统调用后的返回值也放在eax寄存器中，其中正数或0表示系统调用成功，负数表示出错，存放于errno全局变量中。

系统调用处理流程是：

- 将系统调用的参数写入CPU寄存器
- 检查所有的系统调用参数
- 将CPU中的参数拷贝至内核态堆栈
- 调用名为系统调用服务例程（system call service routine）的C函数来处理系统调用
- 退出系统调用处理程序，将内核栈中的值加载至寄存器，并从内核态切换回用户态

为了将系统调用号与对应的服务例程联系起来，内核定义了一个系统调用分派表（system call dispatch table），这个表存放在sys_call_table数组中。内核拿到系统调用号之后，就去sys_call_table中找到对应的系统调用实现函数去执行。执行完毕后，使用返回指令从内核态返回至用户态。

内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠并且可以被抢占。因此必须保证系统调用时可重入的，因为新的进程可能会使用相同的系统调用。

## 信号

在Linux系统中，为了响应各种事件定义了非常多的信号。比如当我们发送kill -9 ${pid}时，其实就是发送SIGKILL信号给指定进程，将它杀死。我们可以通过kill -l命令查看所有的信号。每个信号都有一个唯一的ID和对应的默认操作。

进程对信号的处理方式有三种：

1. 执行默认操作。
2. 自定义信号处理函数。
3. 忽略信号。注意，SIGKILL和SIGSTOP无法忽略。

Linux推荐使用sigaction函数来自定义信号处理函数。它的定义如下：

```C
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

而sigaction结构体的定义如下：

```C
struct sigaction {
  __sighandler_t sa_handler;
  unsigned long sa_flags;
  __sigrestore_t sa_restorer;
  sigset_t sa_mask;   
};
```

其中sa_handler就是你要定义的信号处理函数。

发送信号由两种方式，一种是发送给整个线程组的，还有一种是发送给某个单独线程的。信号分为不可靠信号和可靠信号。在task_struct中有一个结构体sigpending，它的定义如下：

```C
struct sigpending{
    struct list_head list;
    sigset_t signal;
};
```

对于不可靠信号，也就是编号小于32的信号，会放在sigset_t集合中，不论发送多少次，在被处理前都只会保留一份。对于可靠信号，则会挂在struct sigpending的链表中挨个处理。

## 定时器

内核中有大量的函数是基于时间驱动的。有些函数需要周期性执行，有些函数需要等待一个相对时间后才运行。周期性的事件由系统定时器驱动。系统定时器能以固定的频率产生中断，这种中断被称为定时器中断，它所对应的中断处理程序负责更新系统时间和执行周期性任务。

系统定时器的频率被称为节拍率（tick rate），产生的两次时钟中断的间隔就被称为节拍（tick），它等于节拍率分之一秒。内核通过时钟中断间隔来计算系统运行时间。时钟中断需要执行的操作有：

- 更新系统运行时间
- 更新实际时间
- 在smp系统上，均衡调度程序中各处理器上的运行队列
- 检查当前进程是否用尽了自己的时间片
- 运行超时的动态定时器
- 更新资源消耗和处理器时间的统计值

### 节拍率和jiffies变量

系统定时器频率是通过静态预处理定义的，在系统启动时按照HZ的值对硬件进行设置，该值与体系结构相关。内核在<asm/param.h\>文件中定义。在x86体系结构中，系统定时器频率默认为100。也就是说x86的时钟中断频率为100HZ，即每秒中断100次（每10ms产生一次）。

时钟中断频率应设置为一个理想的值，高HZ可以提高系统的性能，使得由时间驱动的事件更为精确。但同时也带来了额外的系统负担，因为处理器会被更频繁地打断去执行时钟中断处理程序。

全局变量jiffies用来记录系统启动以来产生的节拍总数。内核在启动时将该变量初始化为0，此后每产生一次时钟中断该值就+1。因为一秒内时钟中断的次数等于HZ，所以jiffies一秒内增加的值也就为HZ。系统运行时间以秒为计，其值等于jiffies/HZ。

jiffies变量被定义为unsigned long类型。在32位体系结构上是32位。如果时钟频率为100HZ，那么497天后会溢出。如果是64位体系结构，任何人都别指望会看到它溢出。

当jiffies变量的值超过它的最大存放范围后就会发生溢出，此时再继续增加的话，它会回绕至0。为了解决jiffies变量的溢出问题，内核引入了jiffies_64变量，这是一个64位的无符号整数。

### 动态定时器

定时器的使用很简单。你只需要执行一些初始化工作，设置一个超时时间，指定超时发生后需要执行的函数，然后激活定时器就可以了。内核提供了一组与定时器相关的接口用来简化定时器的操作。

创建定时器：

```C
struct timer_list my_timer;
```

初始化定时器：

```C
init_timer(&my_timer);
```

填充定时器结构中的值：

```C
my_timer.expires = jiffies + delay;    //定时器超时节拍数
my_timer.data = 0;                     //定时器处理函数传入的值
my_timer.function = my_function;       //定时器超时回调函数
```

如果当前jiffies计数大于或等于my_timer.expires的值，那么my_timer.function指向的处理函数就会被执行。处理函数必须符合以下类型：

```C
void my_function(unsigned long data);
```

其中data参数使你可以利用同一个处理函数注册多个定时器，只需要通过该参数就可以区别对待它们。如果你不需要这个参数，直接传0即可。

最后，你必须手动激活定时器：

```C
add_timer(&my_timer);
```

一般来说，定时器都会在超时后马上执行，但也有可能会推迟到下一个时钟节拍时才运行，所以不能用定时器来实现任何硬实时的任务。如果需要修改定时器超时时间，可以通过*mod_timer()*函数来实现：

```C
mod_timer(&my_timer, jiffies + new_delay);
```

如果在定时器超时前停止定时器，可以使用*del_timer()*函数：

```C
del_timer(&my_timer);
```

需要注意的是，在多处理器系统中，删除定时器时可能需要等待在其他处理器上运行的定时器处理程序都退出，这时需要用到*del_timer_syn()*函数来执行删除工作。

### 延迟执行

内核代码往往需要推迟某些任务的执行，这种推迟通常发生在等待硬件完成某些工作，而且等待时间往往非常短。内核提供了多种延迟方法来处理延迟请求。

最简单的延迟方法就是忙等待。该方法仅仅在想要延迟的时间是节拍的整数倍，或者精确率要求不高的情况下才可以使用。忙等待的实现非常简单——在一个循环中不断等待直到希望的时钟节拍数耗尽，比如：

```C
unsigned long timeout = jiffies + 10;    //等待10个节拍
while(time_before(jiffies, timeout))
{}
```

该循环将不断执行，直到jiffies 大于delay为止。这是一种低效的办法， 因为处理器除了等待不会做任何事情，更好的方案是在等待时，允许内核重新调度执行其他任务。

基于jiffies的延迟方法受限于时钟节拍，无法提供更短、更精确的延迟要求。为此，内核提供了三个可以处理us、ns和ms级别的延迟函数：

```C
void udelay(unsigned long usecs)
void ndelay(unsigned long nsecs)
void mdelay(unsigned long msecs)
```

更理想的延迟执行方法是使用*schedule_timeout()*函数，该方法让需要延迟执行的任务睡眠到指定延迟时间耗尽后再重新运行。其用法如下：

```C
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout(s * HZ);
```

上述代码将当前任务推入可中断睡眠队列，睡眠s秒后唤醒。注意，由于schedule_timeout()函数需要调用调度程序，所以调用它的代码必须保证能够睡眠。也就是调用函数必须位于进程上下文中，且不能持有锁。

当任务被重新调度时，将返回代码进入睡眠前的位置继续执行。如果任务提前被唤醒，那么定时器被撤销。

