# 其他

> 这里主要放一些零碎的内容。

## 快速导航

- [系统调用](./others.md/#_3)

## 系统调用

> 在阅读本节内容之前，建议先了解一下[中断](./interrupt.md)。

当你的程序调用open, read, write, close等函数时，就会触发系统调用。系统调用本质是用户态进程与硬件设备交互的接口，内核负责检查系统调用的正确性，然后发出指令给硬件。作为应用程序开发者，不用关心底层硬件的实现细节，而只需要调用普通函数就可以使用系统调用了。glibc库进一步封装了细节，因此我们只需要使用glibc库暴露的API即可。

[man page for syscall(2)](https://man7.org/linux/man-pages/man2/syscalls.2.html)列出了所有的系统调用。

### 处理流程

x86体系进入和退出系统调用有两种方式：

- int 0x80 和 iret
- sysenter 和 sysexit

第二种被称为快速系统调用。

无论哪种方式，最终结果都是跳转到系统调用处理函数（system call handler）。由于内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号（system call number）的参数来识别所需的系统调用，这个参数存放在eax寄存器中。执行完系统调用后的返回值也放在eax寄存器中，其中正数或0表示系统调用成功，负数表示出错，存放于errno全局变量中。

系统调用处理流程是：

- 将系统调用的参数写入CPU寄存器
- 检查所有的系统调用参数
- 将CPU中的参数拷贝至内核态堆栈
- 调用名为系统调用服务例程（system call service routine）的C函数来处理系统调用
- 退出系统调用处理程序，将内核栈中的值加载至寄存器，并从内核态切换回用户态

为了将系统调用号与对应的服务例程联系起来，内核定义了一个系统调用分派表（system call dispatch table），这个表存放在sys_call_table数组中。在汇编语言中，使用一条指令跳转至对应的服务例程：

```
call *sys_call_table(0, %eax, 4)
```

