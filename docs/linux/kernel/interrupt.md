# 中断和异常

中断是一种事件，该事件改变处理器执行指令的顺序。这种方式有同步和异步之分。同步中断是由CPU控制单元产生的。而异步中断是由外部硬件设备产生的。

中断又可以分为可屏蔽中断和不可屏蔽中断。通常，I/O设备发出的所有中断请求都是可屏蔽的，而部分危急事件（比如硬件故障）是不可屏蔽的。每个中断和异常都是由0 ~ 255之间的一个数来标识，这个数被称作为是向量（vector）。不可屏蔽中断的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。

显然，中断信号提供了一种特殊的方式，让处理器去执行正常运行代码之外的逻辑。当一个中断信号到来时，CPU必须停下它当前正在做的事情，转而去处理中断代码。为了做到这一点，就需要在内核态堆栈保存当前上下文环境，并且把触发了何种中断也放进寄存器中。

你可能会把中断处理与进程切换联系起来。确实这两者有部分相似之处，但是中断执行的代码不是进程环境。它是一个内核控制的特殊路径，必须快速处理，不能停留。由于中断处理是内核最为敏感的任务之一，为了提高系统的性能，它必须有以下约束：

- 中断必须尽可能快地处理。为此，中断处理通常分为两部分：关键而紧急的部分，内核立即执行；其余部分推迟执行。

- 中断必须可以嵌套执行。由于中断随时会到来，在内核处理其中一个中断时，另一个中断也会发生。当中断处理完成后，内核必须能恢复被中断进程的执行。

- 在临界区中，中断必须被禁止。

每个能够发出中断请求的硬件设备都有一条名为IRQ的输出线。所有的IRQ线都与一个叫可编程中断控制器(Programmable Interrupt Controller, PIC)的硬件电路的输入引脚相连。PIC执行下列动作：

1. 中断请求：当外部设备需要CPU的处理时，它会向中断控制器发出中断请求。这个请求通过一个特定的中断线传递给中断控制器。

2. 中断识别：中断控制器识别中断线上的信号，并确定中断的优先级和类型。它会检查中断屏蔽寄存器（IMR）以确定该中断是否被屏蔽。如果被屏蔽，中断控制器将忽略该中断。

3. 中断处理：如果中断未被屏蔽，中断控制器会将中断请求信号转换为CPU可以理解的中断信号。这通常涉及到将中断请求信号转化为一个中断向量，该向量对应于特定的中断服务例程（ISR）。

4. CPU响应：CPU在执行完每条指令后，会检查是否有中断请求。如果有，且当前允许中断（通过检查EFLAGS寄存器的IF位），CPU会向中断控制器发送应答信号。

5. 中断服务例程执行：中断控制器接收到CPU的应答信号后，将中断向量发送到数据总线，CPU读取该向量并跳转到对应的ISR执行。在ISR中，CPU会执行必要的操作来处理中断。

6. 中断处理完成：当中断服务完成后，CPU会恢复被中断程序的执行状态，并继续执行下一条指令。对于需要EOI（End of Interrupt）信号的情况，CPU会向中断控制器发送EOI信号，表示中断处理完成。

7. 中断控制器状态更新：中断控制器在接收到EOI信号后，会更新其状态，准备处理下一个中断请求。

内核如何知道发生中断后去哪里执行对应的处理函数呢？于是就有了中断描述符表（Interrupt Descriptor Table, IDT）的概念，它用于存放每一个中断或异常向量的入口地址。内核在允许中断发生前，必须先初始化IDT。

## 中断处理


## 软中断和tasklet

## 工作队列

工作队列是一种延后执行的机制，可以将后续的工作交给一个内核线程执行。