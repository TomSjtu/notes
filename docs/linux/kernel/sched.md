# 进程管理与调度

进程就是处于执行期的程序，当我们将代码编译成可执行文件时，输入./a.out，我们就开启了一个新的进程。进程从磁盘加载到内存的过程请参考[程序的装载](../../others/ld.md)。

一个进程相当于一个大型的项目组，这个项目组包含着许多资源，比如打开的文件信息，占用的内存空间，处理器的状态等。而线程就是项目组中执行具体任务的人。就像一个项目组至少得有一个人，一个进程必须得有一个主线程。你可以把所有的任务都交给主线程，但是大部分情况下，我们都会让把一个大的任务拆分成一个个小任务，然后另外开辟线程去处理它们。那么我们是否可以再创建几个进程去处理呢？可以，但是没有必要。首先，进程占用的资源空间很大，而线程是轻量级的，创建的速度非常快。其次，进程之间共享资源非常麻烦，而线程由于是同一个进程下的，他们可以共同访问某些资源。这就好比一个公司下面不同项目组之间交接工作容易扯皮，但是如果大家都在同一个项目组下相对来说就好很多。

在Linux系统下，线程与进程并不特别区分。他们同是一个task_struct结构体，内核在管理和调度的时候，不会管你是进程还是线程，一视同仁。

Linux系统通过*fork()*系统调用创建一个进程，调用fork()的进程称为父进程，新产生的进程称为子进程。fork()函数返回两次，如果是0则是子进程；如果大于0则是父进程。这里给了一段示例代码，你先有个概念，具体内核是如何创建进程的我们后面再讲。

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("子进程，进程ID：%d\n", getpid());
        exit(0);
    } else if (pid > 0) {
        printf("父进程，进程ID：%d\n", getpid());
        wait(NULL);
        printf("子进程结束。\n");
    } else {
        perror("fork失败");
        exit(EXIT_FAILURE);
    }
    return 0;
}
```

通常，新创建的进程都是为了执行不同的程序，调用*exec()*可以创建新的地址空间，并把新的程序替换掉当前程序。Linux内核中，fork()底层是由*clone()*系统调用实现的。子程序通过*exit()*系统调用退出，进程退出后被设置为僵死（zombie）状态，直到父进程使用*wait()*或者*waitpid()*回收子进程的资源。

前面说了，在Linux系统下，不管你是进程还是线程，都统一视作task_struct结构体。这个结构非常复杂，包含了一个进程/线程的所有信息。内核统一将所有task_struct放在一个双向循环列表中管理。

