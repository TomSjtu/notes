# 连续内存分配

连续内存分配(CMA，Continuous Memory Allocator)是内存管理中的一个模块，主要负责物理地址上连续的内存分配。一般系统会在启动过程中，从整个memory中配置一段连续内存用于CMA，然后内核其他的模块可以通过CMA的接口API进行连续内存的分配。CMA的核心并不是设计精巧的算法来管理地址连续的内存块，实际上它的底层还是依赖内核伙伴系统这样的内存管理机制，或者说CMA是处于需要连续内存块的其他内核模块（例如DMA mapping framework）和内存管理模块之间的一个中间层模块，主要功能包括：

- 解析DTS或者命令行中的参数，确定CMA内存的区域，这样的区域我们定义为CMA area。

- 提供`cma_alloc()`和`cma_release()`两个接口函数用于分配和释放CMA pages。

- 记录和跟踪CMA area中各个pages的状态。

- 调用伙伴系统接口，进行真正的内存分配。

!!! question 

    为什么需要CMA？

对大块连续内存的需求主要来自于各种驱动。比如图像、视频驱动。假如拍摄一张高清图像需要分配20MB的内存，你可能觉得这没什么。当然，在系统刚刚启动时，内存的余量还比较充足。但是随着系统的运行，内存不断地分配和释放，大块内存不断地被分解、分解，再分解，内存的碎片化导致分配地址连续的大块内存越来越艰难。一旦内存分配失败，camera功能就无法使用，用户当然不会答应。

ARM64支持多种页面大小——4k、64K甚至更大的page size。但在大多数CPU架构上，Linux内核总是倾向于使用最小的page size——4K。大于4K的page统称为"huge page"。huge page可以帮我们应对大块内存分配的需求，但是page size的设置牵一发而动全身，关系到整个系统的稳定性和性能，因此不能把它当作解决大块内存分配的方法。

CMA就是为了解决上述困境而被引入的。对于标记为CMA的内存，当前驱动没有分配使用的时候，这些内存可以被内核的其他模块使用（当然有一定的要求）。而当驱动要求分配CMA内存后，其他模块需要吐出来，形成物理地址连续的大块内存，给具体的驱动来使用。

