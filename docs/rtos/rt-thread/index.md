# rtt内核简介

> 由于不同RTOS的内核大差不差，这里只记录下rtt内核比较特殊的地方。

rtt内核架构如下图所示：

![Alt text](../../images/rt-thread/Software_framework_diagram.png)

rtt内核模块主要分为：

1. 线程调度
2. 时钟管理
3. 线程间同步与通信
4. 内存管理
5. 中断管理
6. I/O设备管理
7. 外设接口

下图显示了rtt中各类内核对象的派生和继承关系。

![Alt text](../../images/rt-thread/kernel_object.png)

内核对象控制块的数据结构如下：

```C
struct rt_object {
    char name[RT_NAME_MAX];    //内核对象名称
    rt_uint8_t type;           //内核对象类型
    rt_uint8_t flag;           //内核对象参数
    rt_list_t list;            //内核对象管理链表
};
```

内核对象容器的数据结构如下：

```C
struct rt_object_information {
    enum rt_object_class_type type;    //对象类型
    rt_list_t object_list;             //对象链表
    rt_size_t object_size;             //对象大小
};
```

同一类对象由一个rt_object_information结构体来管理，这类对象的每个实例以链表的形式挂在object_list链表上。当某个内核对象被初始化后，该对象就被添加到对应容器中管理。

## 线程管理

rtt中线程状态多了一个初始状态，当线程创建完毕还没开始运行时就处于初始状态，该状态下线程不参与调度，宏定义为RT_THREAD_INIT。初始状态的线程需要调用`rt_thread_startup()`进入就绪状态。

rtt最大支持256个优先级，对于ARM Cortex-M系列一般采用32个优先级。

每个线程都有时间片参数，时间片仅对优先级相同的就绪状态线程有效（即同优先级参与调度）。时间片的单位是一个系统节拍，其意义是线程单次运行的时长。

使用`rt_thread_create()`函数创建一个动态线程，使用`rt_thread_delete()`函数删除一个动态线程。静态线程的API分别是`rt_thread_init()`函数和`rt_thread_detach()`函数。使用`rt_thread_startup()`函数启动线程，`rt_thread_yield()`函数让出线程资源，`rt_thread_delay()`函数使线程睡眠，`rt_thread_resume()`函数恢复线程。

## 时钟管理

全局变量rt_tick每次经过一个时钟节拍，值就会加1，它表示系统从启动开始总共经过的始终节拍数。此外，rt_tick每次加1都会检查当前线程的时间片是否使用完，以及是否有定时器超时。

rtt的定时器可以分为HARD_TIMER模式——在中断环境中执行，和SOFT_TIMER模式——在线程环境中执行。

新创建并激活的定时器都会以超时时间排序的方式插入到rt_timer_list链表中。所有定时器在定时超时后都会从定时器链表中被移除，而周期性定时器会在它再次启动时被加入定时器链表。与定时器有关的操作如下图所示：

![Alt text](../../images/rt-thread/timer_ops.png)

## 线程间同步

### 信号量

信号量相关接口函数如下：

![Alt text](../../images/rt-thread/sem_ops.png)

rtt内核在创建信号量的时候，可以通过flag参数指定信号量不可用时多个线程等待的排队方式。比如RT_IPC_FLAG_FIFO表示按照先进先出的方式排队，RT_IPC_FLAG_PRIO表示按照优先级的方式进行排队。一般采用优先级方式，除非应用程序非常在意先来后到。

### 互斥量

互斥量相关接口函数如下：

![Alt text](../../images/rt-thread/mutex_ops.png)

互斥量主要适用于以下情况：

1. 线程多次持有互斥量，互斥量可以递归持有而信号量会导致死锁。
2. 由于多线程同步而造成优先级反转问题。

### 事件组

rtt定义的事件集有以下特点：

1. 事件只与线程相关，事件间相互独立：每个线程可拥有32个事件标志，采用一个32bit无符号整型数进行记录，每一个bit代表一个事件；

2. 事件仅用于同步，不提供数据传输功能；

3. 事件无排队性，即多次向线程发送同一事件 (如果线程还未来得及读走)，其效果等同于只发送一次。

每个线程都拥有一个事件信息标记，它有三个属性，分别是RT_EVENT_FLAG_AND(逻辑与)，RT_EVENT_FLAG_OR(逻辑或）以及RT_EVENT_FLAG_CLEAR(清除标记）。当线程等待事件同步时，可以通过32个事件标志和这个事件信息标记来判断当前接收的事件是否满足同步条件。

事件组相关接口函数如下：

![Alt text](../../images/rt-thread/event_ops.png)

## 线程间通信

### 邮箱

邮箱的特点是开销比较低，效率较高。邮箱中的每一封邮件只能容纳固定的4字节内容，也就是说邮箱只能用来传输固定大小的内容。邮箱使用一个固定缓冲区大小来存储邮件，其大小在创建时被定义。

非阻塞方式的邮件发送过程能够安全的应用于中断服务中，是线程、中断服务、定时器向线程发送消息的有效手段。根据对应的情况，邮箱的收取或者发送都可以设置为超时阻塞，进入阻塞状态的线程将睡眠，等待对应条件满足后唤醒。

邮箱相关接口函数如下：

![Alt text](../../images/rt-thread/mb_ops.png)

### 消息队列

消息队列是邮箱的扩展，可以用来传输不固定长度的内容。

消息队列需要将消息缓存在自己的内存空间中，因此内存占用比邮箱要大。多个线程能够读取同一个消息队列。而当消息队列是空的时候，可以挂起读取线程。当有新的消息到达时，挂起的线程将被唤醒以接收并处理消息。消息队列是一种异步的通信方式。

消息队列相关接口函数如下：

![Alt text](../../images/rt-thread/msg_ops.png)

### 信号

信号其实是用户层面对硬件中断的一种模拟，一个线程收到信号之后会转去对应的信号处理函数。rtt中使用**rt_sigset_t**类型来定义信号集。

当一个线程收到信号时，如果它处于挂起状态，那么它会改为就绪状态去处理对应的信号。

信号相关接口函数如下：

![Alt text](../../images/rt-thread/signal_ops.png)

在信号的使用过程中，先定义线程需要的信号处理函数，然后使用`rt_signal_install()`函数将**signo**与对应的信号处理函数相关联。

## 内存管理

实时系统要求内存块的分配过程在可预测的时间内完成，否则实时任务对外部事件的响应将变得不确定。rtt内核在内存分配管理算法上，提供了两大类：内存堆管理与内存池管理。而内存对管理又划分为三种情况：小内存管理算法，slab管理算法和memheap管理算法。

### 内存堆管理

小内存管理是一个简单的内存分配算法。初始时，它是一块大内存，当需要分配内存块时，从这块大内存上分割出响应的内存块，空闲的内存块归还给堆管理系统。每个内存块都用双向链表的方式链接起来。通过***used**成员变量标记当前内存块是否已被使用。

slab分配器会根据对象的大小分成多个区（zone），一个zone的大小在32K到128K字节之间，系统中的zone最多包括72种对象，一次性最大可以分配16K的空间。如果超出了16K则直接从页分配器中分配。每个zone上都是固定大小的内存块链接在一起。而72种对象的zone链表则放在一个数组中统一管理，如下图所示：

![Alt text](../../images/rt-thread/slab.png)

memheap管理算法适用于系统有多个不可连续地址的内存堆。用户只需要在系统初始化时将多个所需的memheap初始化，并开启memheap功能就可以将多个memheap粘合起来统一用作内存分配。


在使用内存堆时，必须在系统初始化的时候进行堆的初始化：

```C
void rt_system_heap_init(void *begin_addr, void *end_addr);
```

内存堆管理的相关接口函数如下：

![Alt text](../../images/rt-thread/heap_ops.png)

### 内存池管理

频繁地调用内存分配和释放函数会导致内存碎片，因此rtt引进了另外一种内存管理方法：内存池。

内存池用于分配大量大小相同的小内存块，内存池在创建时先向系统申请一大块内存，然后分成同样大小的多个小内存块，小内存块直接通过链表连接起来（此链表也称为空闲链表）。每次分配的时候，从空闲链表中取出链头上第一个内存块，提供给申请者。内存池一旦初始化完成，内部的内存块大小将不能再做调整。

内存池相关接口函数如下：

![Alt text](../../images/rt-thread/mempool_ops.png)

## 中断管理

